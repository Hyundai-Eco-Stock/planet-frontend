import { useRef, useEffect, useCallback } from 'react';
import { createChart } from 'lightweight-charts';
import { chartConfig, LAYOUT, priceScaleConfig, THEME } from '@/config/chartConfig';

export const useChart = (data, height = 400) => {
    const chartContainerRef = useRef();
    const chartRef = useRef();
    const candleSeriesRef = useRef();
    const volumeSeriesRef = useRef();
    const separatorSeriesRef = useRef();
    const resizeObserverRef = useRef();
    const isInitializedRef = useRef(false);
    const lastDataTimeRef = useRef(null); // ÎßàÏßÄÎßâ Îç∞Ïù¥ÌÑ∞ ÏãúÍ∞Ñ Ï∂îÏ†Å

        // ‚úÖ Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞Î•º ÏßÅÏ†ë Í¥ÄÎ¶¨
    const chartDataRef = useRef([]);
    const volumeDataRef = useRef([]);


    const createExtendedTimeRange = () => {
        const now = Math.floor(Date.now() / 1000);
        return [{ time: now - 86400, value: 1 }, { time: now + 86400, value: 1 }];
    };

    const getVolumeColor = useCallback((colorKey, theme) => {
        switch (colorKey) {
            case "BUY":
                return theme.volume.buy;
            case "SELL":
                return theme.volume.sell;
            case "EMPTY":
                return theme.volume.empty;
            case "SAME":
                return theme.volume.same;
            default:
                return theme.text;
        }
    }, []);

    // Ï∞®Ìä∏ Ï¥àÍ∏∞Ìôî (dataÍ∞Ä Î≥ÄÍ≤ΩÎê† ÎïåÎßå)
    useEffect(() => {
        if (!data || data.length === 0) return;

        // Í∏∞Ï°¥ Ï∞®Ìä∏Í∞Ä ÏûàÎã§Î©¥ Ï†úÍ±∞
        if (chartRef.current) {
            chartRef.current.remove();
            chartRef.current = null;
            candleSeriesRef.current = null;
            volumeSeriesRef.current = null;
            separatorSeriesRef.current = null;
            isInitializedRef.current = false;
            lastDataTimeRef.current = null;
        }

        console.log('üìä Ï∞®Ìä∏ Ï¥àÍ∏∞Ìôî ÏãúÏûë -', data.length, 'Í∞ú Îç∞Ïù¥ÌÑ∞');

        const chart = createChart(
            chartContainerRef.current,
            chartConfig.base(chartContainerRef.current.clientWidth, height)
        );

        chartRef.current = chart;

        const ohlcData = data.ohlcData;
        const volumeData = data.volumeData.map(volume => ({
            ...volume,
            color: getVolumeColor(volume.color, THEME)
        }));
        const separatorData = createExtendedTimeRange();

                // ‚úÖ Ï¥àÍ∏∞ Îç∞Ïù¥ÌÑ∞Î•º refÏóê Ï†ÄÏû•
        chartDataRef.current = [...ohlcData];
        volumeDataRef.current = [...volumeData];

        const candleSeries = chart.addCandlestickSeries(chartConfig.candlestick);
        const volumeSeries = chart.addHistogramSeries(chartConfig.volume);
        const separatorSeries = chart.addLineSeries(chartConfig.separator);

        candleSeriesRef.current = candleSeries;
        volumeSeriesRef.current = volumeSeries;
        separatorSeriesRef.current = separatorSeries;

        chart.priceScale(LAYOUT.priceScaleIds.main).applyOptions(priceScaleConfig.main);
        chart.priceScale(LAYOUT.priceScaleIds.volume).applyOptions(priceScaleConfig.volume);
        chart.priceScale(LAYOUT.priceScaleIds.separator).applyOptions(priceScaleConfig.separator);

        separatorSeries.createPriceLine({
            price: 1,
            color: THEME.separator,
            lineWidth: 1,
            lineStyle: 0,
            axisLabelVisible: false,
            title: ''
        });

        // Ï¥àÍ∏∞ Ï∞®Ìä∏ Îç∞Ïù¥ÌÑ∞ ÏÇΩÏûÖ
        candleSeries.setData(chartDataRef.current);
        volumeSeries.setData(volumeDataRef.current);
        separatorSeries.setData(separatorData);

        // ÎßàÏßÄÎßâ Îç∞Ïù¥ÌÑ∞ ÏãúÍ∞Ñ Ï†ÄÏû•
        if (ohlcData.length > 0) {
            lastDataTimeRef.current = ohlcData[ohlcData.length - 1].time;

            const realDataPoints = ohlcData.filter(item => !item.isEmpty);
            const visibleRealDataCount = Math.min(10, realDataPoints.length);
            const startIndex = Math.max(0, realDataPoints.length - visibleRealDataCount);
            const firstRealTime = realDataPoints[startIndex].time;

            chart.timeScale().setVisibleRange({
                from: firstRealTime - 300,
                to: lastDataTimeRef.current + 300
            });
        }

        isInitializedRef.current = true;
        console.log('‚úÖ Ï∞®Ìä∏ Ï¥àÍ∏∞Ìôî ÏôÑÎ£å');

        return () => {
            if (chartRef.current) {
                chartRef.current.remove();
                chartRef.current = null;
                candleSeriesRef.current = null;
                volumeSeriesRef.current = null;
                separatorSeriesRef.current = null;
                isInitializedRef.current = false;
                lastDataTimeRef.current = null;
                chartDataRef.current = [];
                volumeDataRef.current = [];
            }
        };
    }, [data, height, getVolumeColor]);

    // Î¶¨ÏÇ¨Ïù¥Ï¶à Ï≤òÎ¶¨
    useEffect(() => {
        const handleResize = (entries) => {
            const { width, height: containerHeight } = entries[0].contentRect;
            if (chartRef.current) {
                // ÌòÑÏû¨ Î≥¥Ïù¥Îäî Î≤îÏúÑ Ï†ÄÏû•
                const timeScale = chartRef.current.timeScale();
                const visibleRange = timeScale.getVisibleRange();

                chartRef.current.applyOptions({
                    width,
                    height: containerHeight || height
                });

                // Î¶¨ÏÇ¨Ïù¥Ï¶à ÌõÑ Í∏∞Ï°¥ Î≤îÏúÑ Î≥µÏõê
                setTimeout(() => {
                    if (chartRef.current && visibleRange && visibleRange.from && visibleRange.to) {
                        timeScale.setVisibleRange(visibleRange);
                    }
                }, 0);
            }
        };

        const resizeObserver = new ResizeObserver(handleResize);
        if (chartContainerRef.current) {
            resizeObserver.observe(chartContainerRef.current);
        }
        resizeObserverRef.current = resizeObserver;

        return () => {
            if (resizeObserverRef.current) {
                resizeObserverRef.current.disconnect();
            }
        };
    }, [height]);
    // üî• Í∞ÑÎã®ÌïòÍ≥† ÏûêÏó∞Ïä§Îü¨Ïö¥ Ïã§ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
// Îç∞Ïù¥ÌÑ∞ Î∞∞Ïó¥ÏùÑ ÏßÅÏ†ë Í¥ÄÎ¶¨ÌïòÎäî ÏóÖÎç∞Ïù¥Ìä∏ Ìï®Ïàò
const updateChart = useCallback((currentData) => {
    console.log('Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏ Ìò∏Ï∂ú:', currentData);

    if (!currentData || !isInitializedRef.current || !candleSeriesRef.current) {
        console.log('Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏ Ï°∞Í±¥ Ïã§Ìå®');
        return;
    }

    const ohlc = currentData.ohlcData;
    if (!ohlc || typeof ohlc.time !== 'number' || isNaN(ohlc.time)) {
        console.error('Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ OHLC Îç∞Ïù¥ÌÑ∞:', ohlc);
        return;
    }

    const cleanOhlc = {
        time: ohlc.time,
        open: Number(ohlc.open),
        high: Number(ohlc.high),
        low: Number(ohlc.low),
        close: Number(ohlc.close),
    };

    console.log('Ï≤òÎ¶¨Ìï† cleanOhlc:', cleanOhlc);
    console.log('ÌòÑÏû¨ chartData ÎßàÏßÄÎßâ:', chartDataRef.current[chartDataRef.current.length - 1]);

    try {
        const currentChartData = [...chartDataRef.current];
        const currentVolumeData = [...volumeDataRef.current];
        
        if (!lastDataTimeRef.current || cleanOhlc.time > lastDataTimeRef.current) {
            // ÏÉàÎ°úÏö¥ Î∂ÑÎ¥â Ï∂îÍ∞Ä
            console.log('ÏÉà Î∂ÑÎ¥â Ï∂îÍ∞Ä:', cleanOhlc);
            
            currentChartData.push(cleanOhlc);
            chartDataRef.current = currentChartData;
            lastDataTimeRef.current = cleanOhlc.time;
            
            // Î≥ºÎ•® Îç∞Ïù¥ÌÑ∞ÎèÑ Ï∂îÍ∞Ä
            if (currentData.volumeData) {
                const cleanVolume = {
                    time: cleanOhlc.time,
                    value: Number(currentData.volumeData.value) || 0,
                    color: getVolumeColor(currentData.volumeData.color, THEME),
                };
                currentVolumeData.push(cleanVolume);
                volumeDataRef.current = currentVolumeData;
            }
            
            // Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ Îã§Ïãú ÏÑ§Ï†ï
            candleSeriesRef.current.setData(currentChartData);
            if (volumeSeriesRef.current) {
                volumeSeriesRef.current.setData(currentVolumeData);
            }
            
            console.log('ÏÉà Î∂ÑÎ¥â setData ÏôÑÎ£å');
            
        } else if (cleanOhlc.time === lastDataTimeRef.current) {
            // ÎßàÏßÄÎßâ Î∂ÑÎ¥â ÏóÖÎç∞Ïù¥Ìä∏ 
            console.log('Í∞ôÏùÄ Î∂ÑÎ¥â ÏóÖÎç∞Ïù¥Ìä∏:', cleanOhlc);
            
            const lastIndex = currentChartData.length - 1;
            if (lastIndex >= 0) {
                // Í∏∞Ï°¥ OHLCÏôÄ ÏÉà Îç∞Ïù¥ÌÑ∞ Î≥ëÌï© (high/low ÎàÑÏ†Å)
                const existingOhlc = currentChartData[lastIndex];
                const updatedOhlc = {
                    time: cleanOhlc.time,
                    open: existingOhlc.open, // Ï≤´ open Ïú†ÏßÄ
                    high: Math.max(existingOhlc.high, cleanOhlc.high),
                    low: Math.min(existingOhlc.low, cleanOhlc.low),
                    close: cleanOhlc.close, // ÏµúÏã† close
                };
                
                currentChartData[lastIndex] = updatedOhlc;
                chartDataRef.current = currentChartData;
                
                // Î≥ºÎ•®ÎèÑ ÏóÖÎç∞Ïù¥Ìä∏
                if (currentData.volumeData && currentVolumeData.length > 0) {
                    const volumeIndex = currentVolumeData.length - 1;
                    const cleanVolume = {
                        time: cleanOhlc.time,
                        value: Number(currentData.volumeData.value) || 0,
                        color: getVolumeColor(currentData.volumeData.color, THEME),
                    };
                    currentVolumeData[volumeIndex] = cleanVolume;
                    volumeDataRef.current = currentVolumeData;
                }
                
                // Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞ Îã§Ïãú ÏÑ§Ï†ï
                candleSeriesRef.current.setData(currentChartData);
                if (volumeSeriesRef.current) {
                    volumeSeriesRef.current.setData(currentVolumeData);
                }
                
                console.log('Î∂ÑÎ¥â ÏóÖÎç∞Ïù¥Ìä∏ setData ÏôÑÎ£å:', updatedOhlc);
            }
        } else {
            console.log('Í≥ºÍ±∞ Îç∞Ïù¥ÌÑ∞ Î¨¥Ïãú:', cleanOhlc.time, 'vs', lastDataTimeRef.current);
        }
    } catch (error) {
        console.error('Ï∞®Ìä∏ ÏóÖÎç∞Ïù¥Ìä∏ ÏóêÎü¨:', error, cleanOhlc);
    }
}, [getVolumeColor]);
    // ÏàòÎèôÏúºÎ°ú ÏµúÏã† Îç∞Ïù¥ÌÑ∞Î°ú Ïù¥ÎèôÌïòÎäî Ìï®Ïàò (ÌïÑÏöîÏãú ÏÇ¨Ïö©)
    const scrollToLatest = useCallback(() => {
        if (!chartRef.current || !lastDataTimeRef.current) return;

        const timeScale = chartRef.current.timeScale();
        const currentRange = timeScale.getVisibleRange();
        const rangeSize = currentRange.to - currentRange.from;

        timeScale.setVisibleRange({
            from: lastDataTimeRef.current - rangeSize + 300,
            to: lastDataTimeRef.current + 300
        });
    }, []);

    return {
        chartContainerRef,
        isInitialized: isInitializedRef.current,
        updateChart,
        scrollToLatest // ÌïÑÏöîÏãú ÏµúÏã†ÏúºÎ°ú Ïä§ÌÅ¨Î°§ÌïòÎäî Ìï®Ïàò
    };
};